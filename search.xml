<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>通用Mapper学习笔记</title>
    <url>/2020/04/19/%E9%80%9A%E7%94%A8Mapper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="通用Mapper简介"><a href="#通用Mapper简介" class="headerlink" title="通用Mapper简介"></a>通用Mapper简介</h2><p>通用Mapper是一款非常好用的MyBatis插件，它能够帮助我们自动生成常用增删改查操作的SQL语句，克服MyBatis开发过程中需要大量编写SQL语句的弊端。由于通用Mapper是根据实体类的属性自动生成对应的SQL语句，所以可以说通用Mapper插件是对MyBatis在ORM方面不足的重要补充。</p>
<h2 id="在Spring中整合Mybatis、SpringMVC"><a href="#在Spring中整合Mybatis、SpringMVC" class="headerlink" title="在Spring中整合Mybatis、SpringMVC"></a>在Spring中整合Mybatis、SpringMVC</h2><p>spring中整合mabatis后，mybatis-config.xml这个配置文件中无配置项</p>
<blockquote>
<p>applicationContext.xml、db.properties、log4j.properties、spring-mvc.xml、pom.xml、web.xml</p>
</blockquote>
<p><strong>applicationContext.xml：</strong><br>1、配置注解扫描，管理service和dao<br>2、配置数据库连接池<br>3、整合Mybatis：配置SqlSessionFactory交给IOC管理<br>4、扫描dao接口，即mapper<br>5、配置spring的声明式事务管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">       xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 开启注解扫描，管理service和dao --&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;com.itheima.ssm.service&quot;&gt;</span><br><span class="line">    &lt;&#x2F;context:component-scan&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;com.itheima.ssm.dao&quot;&gt;</span><br><span class="line">    &lt;&#x2F;context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:property-placeholder location&#x3D;&quot;classpath:db.properties&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 配置连接池 --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!-- 把交给IOC管理 SqlSessionFactory --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!-- 传入PageHelper的插件 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;plugins&quot;&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;!-- 传入插件的对象 --&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;com.github.pagehelper.PageInterceptor&quot;&gt;</span><br><span class="line">                    &lt;property name&#x3D;&quot;properties&quot;&gt;</span><br><span class="line">                        &lt;props&gt;</span><br><span class="line">                            &lt;prop key&#x3D;&quot;helperDialect&quot;&gt;oracle&lt;&#x2F;prop&gt;</span><br><span class="line">                            &lt;prop key&#x3D;&quot;reasonable&quot;&gt;true&lt;&#x2F;prop&gt;</span><br><span class="line">                        &lt;&#x2F;props&gt;</span><br><span class="line">                    &lt;&#x2F;property&gt;</span><br><span class="line">                &lt;&#x2F;bean&gt;</span><br><span class="line">            &lt;&#x2F;array&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!-- 扫描dao接口 --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;mapperScanner&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.itheima.ssm.dao&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置Spring的声明式事务管理 --&gt;</span><br><span class="line">    &lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p><strong>spring-mvc.xml:</strong><br>1、配置扫描controller的注解，别的不扫描<br>2、配置视图解析器<br>3、设置静态资源不过滤<br>4、开启对SpringMVC注解的支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc</span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd</span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">		http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd</span><br><span class="line">           &quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 扫描controller的注解，别的不扫描 --&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;com.itheima.ssm.controller&quot;&gt;</span><br><span class="line">    &lt;&#x2F;context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置视图解析器 --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;!-- JSP文件所在的目录 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;pages&#x2F;&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 文件的后缀名 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 设置静态资源不过滤 --&gt;</span><br><span class="line">    &lt;mvc:resources location&#x3D;&quot;&#x2F;css&#x2F;&quot; mapping&#x3D;&quot;&#x2F;css&#x2F;**&quot; &#x2F;&gt;</span><br><span class="line">    &lt;mvc:resources location&#x3D;&quot;&#x2F;img&#x2F;&quot; mapping&#x3D;&quot;&#x2F;img&#x2F;**&quot; &#x2F;&gt;</span><br><span class="line">    &lt;mvc:resources location&#x3D;&quot;&#x2F;js&#x2F;&quot; mapping&#x3D;&quot;&#x2F;js&#x2F;**&quot; &#x2F;&gt;</span><br><span class="line">    &lt;mvc:resources location&#x3D;&quot;&#x2F;plugins&#x2F;&quot; mapping&#x3D;&quot;&#x2F;plugins&#x2F;**&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 开启对SpringMVC注解的支持 --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">        支持AOP的注解支持，AOP底层使用代理技术</span><br><span class="line">        JDK动态代理，要求必须有接口</span><br><span class="line">        cglib代理，生成子类对象，proxy-target-class&#x3D;&quot;true&quot; 默认使用cglib的方式</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy proxy-target-class&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p><strong>web.xml:</strong><br>1、配置加载类路径的配置文件<br>2、配置监听器<br>3、前端控制器（加载classpath:springmvc.xml 服务器启动创建servlet）<br>4、解决中文乱码过滤器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_1.xsd&quot;</span><br><span class="line">         version&#x3D;&quot;3.1&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置加载类路径的配置文件 --&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath*:applicationContext.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;context-param&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置监听器 --&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">    &lt;&#x2F;listener&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 前端控制器（加载classpath:springmvc.xml 服务器启动创建servlet） --&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">        &lt;!-- 配置初始化参数，创建完DispatcherServlet对象，加载springmvc.xml配置文件 --&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;init-param&gt;</span><br><span class="line">        &lt;!-- 服务器启动的时候，让DispatcherServlet对象创建 --&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">    &lt;&#x2F;servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 解决中文乱码过滤器 --&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;&#x2F;filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;welcome-file-list&gt;</span><br><span class="line">        &lt;welcome-file&gt;index.html&lt;&#x2F;welcome-file&gt;</span><br><span class="line">        &lt;welcome-file&gt;index.htm&lt;&#x2F;welcome-file&gt;</span><br><span class="line">        &lt;welcome-file&gt;index.jsp&lt;&#x2F;welcome-file&gt;</span><br><span class="line">        &lt;welcome-file&gt;default.html&lt;&#x2F;welcome-file&gt;</span><br><span class="line">        &lt;welcome-file&gt;default.htm&lt;&#x2F;welcome-file&gt;</span><br><span class="line">        &lt;welcome-file&gt;default.jsp&lt;&#x2F;welcome-file&gt;</span><br><span class="line">    &lt;&#x2F;welcome-file-list&gt;</span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Mybatis的通用mapper环境搭建"><a href="#Spring-Mybatis的通用mapper环境搭建" class="headerlink" title="Spring+Mybatis的通用mapper环境搭建"></a>Spring+Mybatis的通用mapper环境搭建</h2><blockquote>
<p>applicationContext.xml、db.properties、log4j.properties、spring-mvc.xml、pom.xml、web.xml</p>
</blockquote>
<p><strong>首先在spring配置文件中，修改如下的配置：</strong><br>1、配置注解扫描，管理service和dao  不变<br>2、配置数据库连接池  不变<br>3、整合Mybatis：配置SqlSessionFactory交给IOC管理  不变<br>4、扫描dao接口，即mapper  变化：通用Mapper使用：tk.mybatis.spring.mapper.MapperScannerConfigurer<br>5、配置spring的声明式事务管理  不变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">	xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">	xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">	xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">		http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-4.3.xsd</span><br><span class="line">		http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop-4.3.xsd</span><br><span class="line">		http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx-4.3.xsd&quot;&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 配置数据源 --&gt;</span><br><span class="line">	&lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.user&#125;&quot;&#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 整合MyBatis --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;sqlSessionFactoryBean&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 整合通用Mapper所需要做的配置修改： --&gt;</span><br><span class="line">	&lt;!-- 原始全类名：org.mybatis.spring.mapper.MapperScannerConfigurer --&gt;</span><br><span class="line">	&lt;!-- 通用Mapper使用：tk.mybatis.spring.mapper.MapperScannerConfigurer --&gt;</span><br><span class="line">	&lt;bean class&#x3D;&quot;tk.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.atguigu.mapper.mappers&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 配置Service自动扫描的包 --&gt;</span><br><span class="line">	&lt;context:component-scan base-package&#x3D;&quot;com.atguigu.mapper.services&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 配置声明式事务 --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;dataSourceTransactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;aop:config&gt;</span><br><span class="line">		&lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut&#x3D;&quot;execution(* *..*Service.*(..))&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;aop:config&gt;</span><br><span class="line"></span><br><span class="line">	&lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;dataSourceTransactionManager&quot;&gt;</span><br><span class="line">		&lt;tx:attributes&gt;</span><br><span class="line">			&lt;tx:method name&#x3D;&quot;get*&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">			&lt;tx:method name&#x3D;&quot;save*&quot; rollback-for&#x3D;&quot;java.lang.Exception&quot; propagation&#x3D;&quot;REQUIRES_NEW&quot;&#x2F;&gt;</span><br><span class="line">			&lt;tx:method name&#x3D;&quot;remove*&quot; rollback-for&#x3D;&quot;java.lang.Exception&quot; propagation&#x3D;&quot;REQUIRES_NEW&quot;&#x2F;&gt;</span><br><span class="line">			&lt;tx:method name&#x3D;&quot;update*&quot; rollback-for&#x3D;&quot;java.lang.Exception&quot; propagation&#x3D;&quot;REQUIRES_NEW&quot;&#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;tx:attributes&gt;</span><br><span class="line">	&lt;&#x2F;tx:advice&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p><strong>在pom.xml中：</strong><br>增加依赖tk.mybatis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;tk.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mapper&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.0-beta3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="通用Mapper实体类"><a href="#通用Mapper实体类" class="headerlink" title="通用Mapper实体类"></a>通用Mapper实体类</h2><p>考虑到基本数据类型在 Java 类中都有默认值，会导致 MyBatis 在执行相关操作 时很难判断当前字段是否为 null，所以在 MyBatis 环境下使用 Java 实体类时尽量不 要使用基本数据类型，都使用对应的包装类型。</p>
<h2 id="通用Mapper接口"><a href="#通用Mapper接口" class="headerlink" title="通用Mapper接口"></a>通用Mapper接口</h2><p>通用Mapper接口可以自定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 具体操作数据库的Mapper接口，需要继承通用Mapper提供的核心接口：Mapper&lt;Employee&gt;</span><br><span class="line"> * 泛型类型就是实体类的类型</span><br><span class="line"> * @author Lenovo</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface EmployeeMapper extends Mapper&lt;Employee&gt; &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="table"><a href="#table" class="headerlink" title="@table"></a>@table</h3><p>作用：建立实体类和数据库表之间的对应关系。<br>默认规则：实体类类名首字母小写作为表名。Employee 类→employee 表。<br>用法：在@Table 注解的 name 属性中指定目标数据库表的表名</p>
<h3 id="Column"><a href="#Column" class="headerlink" title="@Column"></a>@Column</h3><p>作用：建立实体类字段和数据库表字段之间的对应关系。<br>默认规则： 实体类字段：驼峰式命名 数据库表字段：使用“_”区分各个单词<br>用法：在@Column 注解的 name 属性中指定目标字段的字段名</p>
<h3 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h3><p>@Id 主键明确标记和数据库表中主键字段对应的实体类字段。<br>防止通用 Mapper 将实体类中的所有字段都拿来放在一起作为联合主键。</p>
<h3 id="GeneratedValue"><a href="#GeneratedValue" class="headerlink" title="GeneratedValue"></a>GeneratedValue</h3><p>作用：让通用 Mapper 在执行 insert 操作之后将数据库自动生成的主键值回写到实体类对象中。</p>
<h3 id="Transient"><a href="#Transient" class="headerlink" title="@Transient"></a>@Transient</h3><p>用于标记不与数据库表字段对应的实体类字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Table(name&#x3D;&quot;tabple_emp&quot;)</span><br><span class="line">public class Employee &#123;</span><br><span class="line">	</span><br><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy&#x3D;GenerationType.IDENTITY)</span><br><span class="line">private Integer empId;&#x2F;&#x2F;emp_id</span><br><span class="line"></span><br><span class="line">private String empName;&#x2F;&#x2F;emp_name</span><br><span class="line"></span><br><span class="line">@Column(name&#x3D;&quot;emp_salary_apple&quot;)</span><br><span class="line">private Double empSalary;&#x2F;&#x2F;emp_salary_apple</span><br><span class="line"></span><br><span class="line">private Integer empAge;&#x2F;&#x2F;emp_age</span><br><span class="line"></span><br><span class="line">public Employee() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="QBC-查询"><a href="#QBC-查询" class="headerlink" title="QBC 查询"></a>QBC 查询</h2><p>Query By Criteria Criteria 是 Criterion 的复数形式。意思是：规则、标准、准则。<br>在 SQL 语句中相当于查询条件。 QBC 查询是将查询条件通过 Java 对象进行模块化封装。</p>
<p>SelectByExample方法的调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">	public void testSelectByExample() &#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;目标：WHERE (emp_salary&gt;? AND emp_age&lt;?) OR (emp_salary&lt;? AND emp_age&gt;?)</span><br><span class="line">		&#x2F;&#x2F;1.创建Example对象</span><br><span class="line">		Example example &#x3D; new Example(Employee.class);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;***********************</span><br><span class="line">		&#x2F;&#x2F;i.设置排序信息</span><br><span class="line">		example.orderBy(&quot;empSalary&quot;).asc().orderBy(&quot;empAge&quot;).desc();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;ii.设置“去重”</span><br><span class="line">		example.setDistinct(true);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;iii.设置select字段</span><br><span class="line">		example.selectProperties(&quot;empName&quot;,&quot;empSalary&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;***********************</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2.通过Example对象创建Criteria对象</span><br><span class="line">		Criteria criteria01 &#x3D; example.createCriteria();</span><br><span class="line">		Criteria criteria02 &#x3D; example.createCriteria();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;3.在两个Criteria对象中分别设置查询条件</span><br><span class="line">		&#x2F;&#x2F;property参数：实体类的属性名</span><br><span class="line">		&#x2F;&#x2F;value参数：实体类的属性值</span><br><span class="line">		criteria01.andGreaterThan(&quot;empSalary&quot;, 3000)</span><br><span class="line">				  .andLessThan(&quot;empAge&quot;, 25);</span><br><span class="line">		</span><br><span class="line">		criteria02.andLessThan(&quot;empSalary&quot;, 5000)</span><br><span class="line">				  .andGreaterThan(&quot;empAge&quot;, 30);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;4.使用OR关键词组装两个Criteria对象</span><br><span class="line">		example.or(criteria02);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;5.执行查询</span><br><span class="line">		List&lt;Employee&gt; empList &#x3D; employeeService.getEmpListByExample(example);</span><br><span class="line">		</span><br><span class="line">		for (Employee employee : empList) &#123;</span><br><span class="line">			System.out.println(employee);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义Mapper"><a href="#自定义Mapper" class="headerlink" title="自定义Mapper"></a>自定义Mapper</h2><p>spring配置文件中指定我们自定义的mapper接口，在properties的属性中配置mappers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 整合通用Mapper所需要做的配置修改： --&gt;</span><br><span class="line">&lt;!-- 原始全类名：org.mybatis.spring.mapper.MapperScannerConfigurer --&gt;</span><br><span class="line">&lt;!-- 通用Mapper使用：tk.mybatis.spring.mapper.MapperScannerConfigurer --&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;tk.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.atguigu.mapper.mappers&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;properties&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            mappers&#x3D;com.atguigu.mapper.mine_mappers.MyMapper</span><br><span class="line">        &lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="通用Mapper逆向工程"><a href="#通用Mapper逆向工程" class="headerlink" title="通用Mapper逆向工程"></a>通用Mapper逆向工程</h2><h3 id="pom-xml配置"><a href="#pom-xml配置" class="headerlink" title="pom.xml配置"></a>pom.xml配置</h3><p><strong>pom.xml中引入properties：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;!-- $&#123;basedir&#125;引用工程根目录 --&gt;</span><br><span class="line">    &lt;!-- targetJavaProject：声明存放源码的目录位置 --&gt;</span><br><span class="line">    &lt;targetJavaProject&gt;$&#123;basedir&#125;&#x2F;src&#x2F;main&#x2F;java&lt;&#x2F;targetJavaProject&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- targetMapperPackage：声明MBG生成XxxMapper接口后存放的package位置 --&gt;</span><br><span class="line">    &lt;targetMapperPackage&gt;com.atguigu.shop.mappers&lt;&#x2F;targetMapperPackage&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- targetModelPackage：声明MBG生成实体类后存放的package位置 --&gt;</span><br><span class="line">    &lt;targetModelPackage&gt;com.atguigu.shop.entities&lt;&#x2F;targetModelPackage&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- targetResourcesProject：声明存放资源文件和XML配置文件的目录位置 --&gt;</span><br><span class="line">    &lt;targetResourcesProject&gt;$&#123;basedir&#125;&#x2F;src&#x2F;main&#x2F;resources&lt;&#x2F;targetResourcesProject&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- targetXMLPackage：声明存放具体XxxMapper.xml文件的目录位置 --&gt;</span><br><span class="line">    &lt;targetXMLPackage&gt;mappers&lt;&#x2F;targetXMLPackage&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 通用Mapper的版本号 --&gt;</span><br><span class="line">    &lt;mapper.version&gt;4.0.0-beta3&lt;&#x2F;mapper.version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- MySQL驱动版本号 --&gt;</span><br><span class="line">    &lt;mysql.version&gt;5.1.37&lt;&#x2F;mysql.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>
<p><strong>pom.xml中配置MBG:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- 配置generatorConfig.xml配置文件的路径 --&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;configurationFile&gt;$&#123;basedir&#125;&#x2F;src&#x2F;main&#x2F;resources&#x2F;generator&#x2F;generatorConfig.xml&lt;&#x2F;configurationFile&gt;</span><br><span class="line">                &lt;overwrite&gt;true&lt;&#x2F;overwrite&gt;</span><br><span class="line">                &lt;verbose&gt;true&lt;&#x2F;verbose&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- MBG插件的依赖信息 --&gt;</span><br><span class="line">            &lt;dependencies&gt;</span><br><span class="line">                &lt;dependency&gt;</span><br><span class="line">                    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;dependency&gt;</span><br><span class="line">                &lt;dependency&gt;</span><br><span class="line">                    &lt;groupId&gt;tk.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;mapper&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;$&#123;mapper.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;&#x2F;dependencies&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>
<p><strong>pom.xml中需要配置mybatis和tk的依赖：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;tk.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mapper&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.0.0-beta3&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.2.8&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<h3 id="generator-generatorConfig-xml配置"><a href="#generator-generatorConfig-xml配置" class="headerlink" title="generator/generatorConfig.xml配置"></a>generator/generatorConfig.xml配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">	&lt;!-- 引入外部属性文件 --&gt;</span><br><span class="line">	&lt;properties resource&#x3D;&quot;config.properties&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;context id&#x3D;&quot;Mysql&quot; targetRuntime&#x3D;&quot;MyBatis3Simple&quot;</span><br><span class="line">		defaultModelType&#x3D;&quot;flat&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;beginningDelimiter&quot; value&#x3D;&quot;&#96;&quot; &#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;endingDelimiter&quot; value&#x3D;&quot;&#96;&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 配置通用Mapper的MBG插件相关信息 --&gt;</span><br><span class="line">		&lt;plugin type&#x3D;&quot;$&#123;mapper.plugin&#125;&quot;&gt;</span><br><span class="line">			&lt;property name&#x3D;&quot;mappers&quot; value&#x3D;&quot;$&#123;mapper.Mapper&#125;&quot; &#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;plugin&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 配置连接数据库的基本信息 --&gt;</span><br><span class="line">		&lt;jdbcConnection </span><br><span class="line">			driverClass&#x3D;&quot;$&#123;jdbc.driverClass&#125;&quot;</span><br><span class="line">			connectionURL&#x3D;&quot;$&#123;jdbc.url&#125;&quot; </span><br><span class="line">			userId&#x3D;&quot;$&#123;jdbc.user&#125;&quot; </span><br><span class="line">			password&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&gt;</span><br><span class="line">		&lt;&#x2F;jdbcConnection&gt;</span><br><span class="line">	</span><br><span class="line">		&lt;!-- 配置Java实体类存放位置 --&gt;</span><br><span class="line">		&lt;javaModelGenerator </span><br><span class="line">			targetPackage&#x3D;&quot;$&#123;targetModelPackage&#125;&quot;</span><br><span class="line">			targetProject&#x3D;&quot;$&#123;targetJavaProject&#125;&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 配置XxxMapper.xml存放位置 --&gt;</span><br><span class="line">		&lt;sqlMapGenerator </span><br><span class="line">			targetPackage&#x3D;&quot;$&#123;targetXMLPackage&#125;&quot;</span><br><span class="line">			targetProject&#x3D;&quot;$&#123;targetResourcesProject&#125;&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 配置XxxMapper.java存放位置 --&gt;</span><br><span class="line">		&lt;javaClientGenerator </span><br><span class="line">			targetPackage&#x3D;&quot;$&#123;targetMapperPackage&#125;&quot;</span><br><span class="line">			targetProject&#x3D;&quot;$&#123;targetJavaProject&#125;&quot; </span><br><span class="line">			type&#x3D;&quot;XMLMAPPER&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 根据数据库表生成Java文件的相关规则 --&gt;</span><br><span class="line">		&lt;!-- tableName&#x3D;&quot;%&quot;表示数据库中所有表都参与逆向工程，此时使用默认规则 --&gt;</span><br><span class="line">		&lt;!-- 默认规则：table_dept→TableDept --&gt;</span><br><span class="line">		&lt;!-- 不符合默认规则时需要使用tableName和domainObjectName两个属性明确指定 --&gt;</span><br><span class="line">		&lt;table tableName&#x3D;&quot;tabple_emp&quot; domainObjectName&#x3D;&quot;Employee&quot;&gt;</span><br><span class="line">			&lt;!-- 配置主键生成策略 --&gt;</span><br><span class="line">			&lt;generatedKey column&#x3D;&quot;emp_id&quot; sqlStatement&#x3D;&quot;Mysql&quot; identity&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;table&gt;</span><br><span class="line">	&lt;&#x2F;context&gt;</span><br><span class="line">&lt;&#x2F;generatorConfiguration&gt;</span><br></pre></td></tr></table></figure>


<h3 id="config-properties中配置"><a href="#config-properties中配置" class="headerlink" title="config.properties中配置"></a>config.properties中配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Database connection information</span><br><span class="line">jdbc.driverClass &#x3D; com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url &#x3D; jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;common_mapper</span><br><span class="line">jdbc.user &#x3D; root</span><br><span class="line">jdbc.password &#x3D; root</span><br><span class="line"></span><br><span class="line">#c3p0</span><br><span class="line">jdbc.maxPoolSize&#x3D;50</span><br><span class="line">jdbc.minPoolSize&#x3D;10</span><br><span class="line">jdbc.maxStatements&#x3D;100</span><br><span class="line">jdbc.testConnection&#x3D;true</span><br><span class="line"></span><br><span class="line"># mapper</span><br><span class="line">mapper.plugin &#x3D; tk.mybatis.mapper.generator.MapperPlugin</span><br><span class="line">mapper.Mapper &#x3D; tk.mybatis.mapper.common.Mapper</span><br></pre></td></tr></table></figure>

<h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn mybatis-generator:generate</span><br></pre></td></tr></table></figure>

<h3 id="mybatis下java方式的逆向工程测试"><a href="#mybatis下java方式的逆向工程测试" class="headerlink" title="mybatis下java方式的逆向工程测试"></a>mybatis下java方式的逆向工程测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MBGTest &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class="line">		</span><br><span class="line">		InputStream inputStream &#x3D; MBGTest.class.getClassLoader().getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		</span><br><span class="line">		SqlSessionFactory factory &#x3D; builder.build(inputStream);</span><br><span class="line">		</span><br><span class="line">		SqlSession session &#x3D; factory.openSession();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;***********************</span><br><span class="line">		&#x2F;&#x2F;按照Java方式整合通用Mapper的特殊设置</span><br><span class="line">		&#x2F;&#x2F;i.创建MapperHelper对象</span><br><span class="line">		MapperHelper mapperHelper &#x3D; new MapperHelper();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;ii.通过MapperHelper对象对MyBatis原生的Configuration对象进行处理</span><br><span class="line">		Configuration configuration &#x3D; session.getConfiguration();</span><br><span class="line">		mapperHelper.processConfiguration(configuration);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;***********************</span><br><span class="line">		</span><br><span class="line">		EmployeeMapper mapper &#x3D; session.getMapper(EmployeeMapper.class);</span><br><span class="line">		</span><br><span class="line">		Iterator&lt;Employee&gt; iterator &#x3D; mapper.selectAll().iterator();</span><br><span class="line">		</span><br><span class="line">		while (iterator.hasNext()) &#123;</span><br><span class="line">			Employee employee &#x3D; (Employee) iterator.next();</span><br><span class="line">			System.out.println(employee);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓展Mapper"><a href="#拓展Mapper" class="headerlink" title="拓展Mapper"></a>拓展Mapper</h2><p>在jdbc.properties中需要在url的值中加入&amp;allowMutiQueries=true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface MyBatchUpdateMapper&lt;T&gt; &#123;</span><br><span class="line">	</span><br><span class="line">	@UpdateProvider(type&#x3D;MyBatchUpdateProvider.class, method&#x3D;&quot;dynamicSQL&quot;)</span><br><span class="line">	void batchUpdate(List&lt;T&gt; list);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyBatchUpdateProvider extends MapperTemplate &#123;</span><br><span class="line"></span><br><span class="line">	public MyBatchUpdateProvider(Class&lt;?&gt; mapperClass, MapperHelper mapperHelper) &#123;</span><br><span class="line">		super(mapperClass, mapperHelper);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;*</span><br><span class="line">		&lt;foreach collection&#x3D;&quot;list&quot; item&#x3D;&quot;record&quot; separator&#x3D;&quot;;&quot; &gt;</span><br><span class="line">			UPDATE tabple_emp</span><br><span class="line">			&lt;set&gt;</span><br><span class="line">				emp_name&#x3D;#&#123;record.empName&#125;,</span><br><span class="line">				emp_age&#x3D;#&#123;record.empAge&#125;,</span><br><span class="line">				emp_salary&#x3D;#&#123;record.empSalary&#125;,</span><br><span class="line">			&lt;&#x2F;set&gt;</span><br><span class="line">			where emp_id&#x3D;#&#123;record.empId&#125;</span><br><span class="line">		&lt;&#x2F;foreach&gt;</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public String batchUpdate(MappedStatement statement) &#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;1.创建StringBuilder用于拼接SQL语句的各个组成部分</span><br><span class="line">		StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2.拼接foreach标签</span><br><span class="line">		builder.append(&quot;&lt;foreach collection&#x3D;\&quot;list\&quot; item&#x3D;\&quot;record\&quot; separator&#x3D;\&quot;;\&quot; &gt;&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;3.获取实体类对应的Class对象</span><br><span class="line">		Class&lt;?&gt; entityClass &#x3D; super.getEntityClass(statement);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;4.获取实体类在数据库中对应的表名</span><br><span class="line">		String tableName &#x3D; super.tableName(entityClass);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;5.生成update子句</span><br><span class="line">		String updateClause &#x3D; SqlHelper.updateTable(entityClass, tableName);</span><br><span class="line">		</span><br><span class="line">		builder.append(updateClause);</span><br><span class="line">		</span><br><span class="line">		builder.append(&quot;&lt;set&gt;&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;6.获取所有字段信息</span><br><span class="line">		Set&lt;EntityColumn&gt; columns &#x3D; EntityHelper.getColumns(entityClass);</span><br><span class="line">		</span><br><span class="line">		String idColumn &#x3D; null;</span><br><span class="line">		String idHolder &#x3D; null;</span><br><span class="line">		</span><br><span class="line">		for (EntityColumn entityColumn : columns) &#123;</span><br><span class="line">			</span><br><span class="line">			boolean isPrimaryKey &#x3D; entityColumn.isId();</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;7.判断当前字段是否为主键</span><br><span class="line">			if(isPrimaryKey) &#123;</span><br><span class="line">				</span><br><span class="line">				&#x2F;&#x2F;8.缓存主键的字段名和字段值</span><br><span class="line">				idColumn &#x3D; entityColumn.getColumn();</span><br><span class="line">				</span><br><span class="line">				&#x2F;&#x2F;※返回格式如:#&#123;record.age,jdbcType&#x3D;NUMERIC,typeHandler&#x3D;MyTypeHandler&#125;</span><br><span class="line">				idHolder &#x3D; entityColumn.getColumnHolder(&quot;record&quot;);</span><br><span class="line">				</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				</span><br><span class="line">				&#x2F;&#x2F;9.使用非主键字段拼接SET子句</span><br><span class="line">				String column &#x3D; entityColumn.getColumn();</span><br><span class="line">				String columnHolder &#x3D; entityColumn.getColumnHolder(&quot;record&quot;);</span><br><span class="line">				</span><br><span class="line">				builder.append(column).append(&quot;&#x3D;&quot;).append(columnHolder).append(&quot;,&quot;);</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		builder.append(&quot;&lt;&#x2F;set&gt;&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;10.使用前面缓存的主键名、主键值拼接where子句</span><br><span class="line">		builder.append(&quot;where &quot;).append(idColumn).append(&quot;&#x3D;&quot;).append(idHolder);</span><br><span class="line">		</span><br><span class="line">		builder.append(&quot;&lt;&#x2F;foreach&gt;&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;11.将拼接好的字符串返回</span><br><span class="line">		return builder.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>MyBatis 配置文件开启二级缓存功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt; &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure>
<p>在 XxxMapper 接口上使用@CacheNamespace 注解</p>
<h2 id="类型转换器TypeHandler"><a href="#类型转换器TypeHandler" class="headerlink" title="类型转换器TypeHandler"></a>类型转换器TypeHandler</h2><h3 id="对象类型的自定义类型转换器"><a href="#对象类型的自定义类型转换器" class="headerlink" title="对象类型的自定义类型转换器"></a>对象类型的自定义类型转换器</h3><p>继承BaseTypeHandler</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将 parameter 对象转换为字符串存入到 ps 对象的 i 位置 </span><br><span class="line">public abstract void setNonNullParameter( </span><br><span class="line">PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;</span><br><span class="line">&#x2F;&#x2F;从结果集中获取数据库对应查询结果 </span><br><span class="line">&#x2F;&#x2F;将字符串还原为原始的 T 类型对象 </span><br><span class="line">public abstract T getNullableResult( ResultSet rs, String columnName) throws SQLException; </span><br><span class="line">public abstract T getNullableResult( ResultSet rs, int columnIndex) throws SQLException; </span><br><span class="line">public abstract T getNullableResult( CallableStatement cs, int columnIndex) throws SQLException;</span><br></pre></td></tr></table></figure>
<p>自定义类型转换器的注册</p>
<p>1、字段级别：@ColumnType 注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ColumnType(typeHandler&#x3D;AddressTypeHandler.class)</span><br><span class="line">private SeasonEnum season;</span><br></pre></td></tr></table></figure>
<p>2、全局级别：在 MyBatis 配置文件中配置 typeHandlers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Column</span><br><span class="line">private SeasonEnum season;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;typeHandlers&gt;</span><br><span class="line">    &lt;!-- handler属性：指定自定义类型转换器全类名 --&gt;</span><br><span class="line">    &lt;!-- javaType属性：指定需要使用“自定义类型转换器”进行类型处理的实体类型 --&gt;</span><br><span class="line">    &lt;typeHandler </span><br><span class="line">        handler&#x3D;&quot;com.atguigu.mapper.handlers.AddressTypeHandler&quot;</span><br><span class="line">        javaType&#x3D;&quot;com.atguigu.mapper.entities.Address&quot;&#x2F;&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;typeHandler </span><br><span class="line">        handler&#x3D;&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;</span><br><span class="line">        javaType&#x3D;&quot;com.atguigu.mapper.entities.SeasonEnum&quot;&#x2F;&gt;</span><br><span class="line">        </span><br><span class="line">&lt;&#x2F;typeHandlers&gt;</span><br></pre></td></tr></table></figure>

<h3 id="枚举类型的类型转换器"><a href="#枚举类型的类型转换器" class="headerlink" title="枚举类型的类型转换器"></a>枚举类型的类型转换器</h3><h4 id="让通用-Mapper-把枚举类型作为简单类型处理，本质使用了-org-apache-ibatis-type-EnumTypeHandler"><a href="#让通用-Mapper-把枚举类型作为简单类型处理，本质使用了-org-apache-ibatis-type-EnumTypeHandler" class="headerlink" title="让通用 Mapper 把枚举类型作为简单类型处理，本质使用了 org.apache.ibatis.type.EnumTypeHandler"></a>让通用 Mapper 把枚举类型作为简单类型处理，本质使用了 org.apache.ibatis.type.EnumTypeHandler<E></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 整合通用Mapper所需要做的配置修改： --&gt;</span><br><span class="line">&lt;!-- 原始全类名：org.mybatis.spring.mapper.MapperScannerConfigurer --&gt;</span><br><span class="line">&lt;!-- 通用Mapper使用：tk.mybatis.spring.mapper.MapperScannerConfigurer --&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;tk.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.atguigu.mapper.mappers&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;properties&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            enumAsSimpleType&#x3D;true</span><br><span class="line">        &lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="为枚举类型配置对应的类型处理器"><a href="#为枚举类型配置对应的类型处理器" class="headerlink" title="为枚举类型配置对应的类型处理器"></a>为枚举类型配置对应的类型处理器</h4><p><strong>1、内置类型转换器</strong><br>org.apache.ibatis.type.EnumTypeHandler<E>  在数据库中存储枚举值本身<br>org.apache.ibatis.type.EnumOrdinalTypeHandler<E>  在数据库中仅仅存储枚举值的索引</p>
<p><strong>类型转换器的注册</strong><br>1、不能使用@ColumnType 注解，因为有范型<br>2、全局级别注册</p>
<p><strong>2、自定义</strong></p>
]]></content>
      <categories>
        <category>编程框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>通用Mapper</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义Mybatis的实现</title>
    <url>/2020/04/07/%E8%87%AA%E5%AE%9A%E4%B9%89Mybatis%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="Mybatis框架分析"><a href="#Mybatis框架分析" class="headerlink" title="Mybatis框架分析"></a>Mybatis框架分析</h3><p>Mybatis框架基于java，为开发者提供优质的持久层服务。Mybatis采用ORM思想，对jdbc进行封装，通过xml配置或者注解的方式，完成对数据库的持久化操作。</p>
<p>在maven工程中，使用Mybatis需要引入MYbatis相关坐标。具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.4.5&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.6&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.2.12&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.10&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>坐标引入后，需要建立一个主配置文件，该文件中配置Mybatis的主要配置。包括mysql环境，事务类型，数据库连接池的配置以及映射配置文件的位置等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 配置环境 --&gt;</span><br><span class="line">    &lt;environments default&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">        &lt;!-- 配置mysql的环境--&gt;</span><br><span class="line">        &lt;environment id&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">            &lt;!-- 配置事务的类型--&gt;</span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;</span><br><span class="line">            &lt;!-- 配置数据源（连接池） --&gt;</span><br><span class="line">            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;!-- 配置连接数据库的4个基本信息 --&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">&lt;!--                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis&quot;&#x2F;&gt;--&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;mybatis?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;1234&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;dataSource&gt;</span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line">    &lt;&#x2F;environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource&#x3D;&quot;com&#x2F;itheima&#x2F;dao&#x2F;IUserDao.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p>主配置文件配置完成后，根据需要建立持久层的接口，并建立与数据库中表对应的实体类。完成这些配置后，就可以选择配置文件或者注解的方式，配置Mybatis的数据库操作。<br>Mybatis通过配置文件或者注解的方式，实现持久层接口的操作数据库的方法。</p>
<h3 id="Mybatis运行分析"><a href="#Mybatis运行分析" class="headerlink" title="Mybatis运行分析"></a>Mybatis运行分析</h3><p>测试类如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MybatisTest &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 入门案例</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args)throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;1.读取配置文件</span><br><span class="line">        InputStream in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;2.创建SqlSessionFactory工厂</span><br><span class="line">        SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory &#x3D; builder.build(in);</span><br><span class="line">        &#x2F;&#x2F;3.使用工厂生产SqlSession对象</span><br><span class="line">        SqlSession session &#x3D; factory.openSession();</span><br><span class="line">        &#x2F;&#x2F;4.使用SqlSession创建Dao接口的代理对象</span><br><span class="line">        IUserDao userDao &#x3D; session.getMapper(IUserDao.class);</span><br><span class="line">        &#x2F;&#x2F;5.使用代理对象执行方法</span><br><span class="line">        List&lt;User&gt; users &#x3D; userDao.findAll();</span><br><span class="line">        for(User user : users)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;6.释放资源</span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Mybatis读取主配置文件后，封装配置信息到Configuration类中，具体包括数据库信息，映射配置文件map等。之后创建SqlSessionFactory工厂，并调用build方法创建工厂。使用工厂生产SqlSession对象，SqlSession创建Dao接口的代理对象。使用代理对象执行Dao中的方法。最后释放资源。</p>
<p>整个过程涉及到工厂模式，构造者模式及代理模式。还涉及到反射，注解，xml解析等。</p>
<h3 id="自定义Mybatis"><a href="#自定义Mybatis" class="headerlink" title="自定义Mybatis"></a>自定义Mybatis</h3><p>自定义Mybatis，pom.xml中去掉Mybatis坐标。我们自己实现整个的xml解析流程及构造者对象，工厂对象，代理对象的创建。</p>
<p>在导入主配置文件后，自定义bulider对象及工厂对象，将主配置文件作为参数创建工厂。创建工厂的方法中解析xml文件，需要用到解析工具类，我们选择dom4j+xpath。自定义Configuration及Mapper类，用来存放我们解析的数据。其中Configuration中保存Mapper数组字段。</p>
<p>解析后返回一个带有Configuration的默认工厂。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SqlSessionFactoryBuilder &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据参数的字节输入流来构建一个SqlSessionFactory工厂</span><br><span class="line">     * @param config</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public SqlSessionFactory build(InputStream config)&#123;</span><br><span class="line">        Configuration cfg &#x3D; XMLConfigBuilder.loadConfiguration(config);</span><br><span class="line">        return  new DefaultSqlSessionFactory(cfg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建好工厂后，调用openSession创建SqlSession对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DefaultSqlSessionFactory implements SqlSessionFactory&#123;</span><br><span class="line"></span><br><span class="line">    private Configuration cfg;</span><br><span class="line"></span><br><span class="line">    public DefaultSqlSessionFactory(Configuration cfg)&#123;</span><br><span class="line">        this.cfg &#x3D; cfg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于创建一个新的操作数据库对象</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public SqlSession openSession() &#123;</span><br><span class="line">        return new DefaultSqlSession(cfg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用SqlSession对象中的getMapper方法，创建daoInterfaceClass的代理对象。在代理对象中增强接口方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 用于创建代理对象</span><br><span class="line">    * @param daoInterfaceClass dao的接口字节码</span><br><span class="line">    * @param &lt;T&gt;</span><br><span class="line">    * @return</span><br><span class="line">    *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; daoInterfaceClass) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(daoInterfaceClass.getClassLoader(),</span><br><span class="line">            new Class[]&#123;daoInterfaceClass&#125;,new MapperProxy(cfg.getMappers(),connection));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理对象的创建依赖MapperProxy类中invoke方法的实现。invoke中需要根据method方法，利用反射得到方法名称及所在类的名称。从而确定在配置文件中Mapper对象是否有对应key。如果有对应key，则可以根据key调用不同的Executor工具类的方法。Mapper中的value对应着sql语句及封装对象，与connection一起作为参数传递给Executor工具类的方法。<br>根据不同的配置选择不同的方法。比如配置select，则调用Executor的selectList方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    &#x2F;&#x2F;1.获取方法名</span><br><span class="line">    String methodName &#x3D; method.getName();</span><br><span class="line">    &#x2F;&#x2F;2.获取方法所在类的名称</span><br><span class="line">    String className &#x3D; method.getDeclaringClass().getName();</span><br><span class="line">    &#x2F;&#x2F;3.组合key</span><br><span class="line">    String key &#x3D; className+&quot;.&quot;+methodName;</span><br><span class="line">    &#x2F;&#x2F;4.获取mappers中的Mapper对象</span><br><span class="line">    Mapper mapper &#x3D; mappers.get(key);</span><br><span class="line">    &#x2F;&#x2F;5.判断是否有mapper</span><br><span class="line">    if(mapper &#x3D;&#x3D; null)&#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;传入的参数有误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;6.调用工具类执行查询所有</span><br><span class="line">    return new Executor().selectList(mapper,conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Executor工具类在此不展开赘述。主要功能是根据传递进来的connection和mapper信息，解析出数据库的各种信息，实现对数据库的增删改查的操作，并封装结果集为目标对象，最后返回结果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自定义Mabatis，根据Mybatis思想，借助工具类和自定义类实现Mybatis基本功能。在这个过程中，加深了对Mybatis处理流程的理解。<br>详细代码见我的博客。</p>
]]></content>
      <categories>
        <category>编程框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis搭建注意事项</title>
    <url>/2020/04/06/Mybatis%E6%90%AD%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="Mybatis连接数据库配置文件"><a href="#Mybatis连接数据库配置文件" class="headerlink" title="Mybatis连接数据库配置文件"></a>Mybatis连接数据库配置文件</h3><p>Mybatis连接数据库配置文件可能会出现如下问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error querying database.  Cause: java.sql.SQLException: Unknown initial character set index &#39;255&#39; received from server.</span><br></pre></td></tr></table></figure>
<p>查找解决方案，可借鉴该回答：<br><a href="https://blog.csdn.net/txwtech/article/details/80787886" target="_blank" rel="noopener">https://blog.csdn.net/txwtech/article/details/80787886</a><br>问题原因在于：字符集设置出现问题。MySQL驱动和数据库字符集设置不搭配<br>在druid.properies等数据库连接池配置文件中需要如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driverClassName&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line">url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;traveltest?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;userSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8</span><br><span class="line">username&#x3D;root</span><br><span class="line">password&#x3D;zxcvbnm123</span><br></pre></td></tr></table></figure>
<p>在Mybatis的配置文件中需要如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;eesy_mybatis?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="报错：java-不支持发行版本5"><a href="#报错：java-不支持发行版本5" class="headerlink" title="报错：java 不支持发行版本5"></a>报错：java 不支持发行版本5</h3><p>Maven项目，运行时报错如下：Error : java 不支持发行版本5。<br>项目编译配置使用的Java版本不对，需要检查一下项目及环境使用的Java编译版本配置。</p>
<ul>
<li>在Intellij中点击“File” –&gt;“Project Structure”，看一下“Project”和“Module”栏目中Java版本是否与本地一致,如果不一致，改成本地使用的Java版本。</li>
<li>点击“Settings”–&gt;“Bulid, Execution,Deployment”–&gt;“Java Compiler”，Target bytecode version设为本地Java版本。（可以在Default Settings中把Project bytecode version 一劳永逸地配置成本地Java版本）。</li>
</ul>
]]></content>
      <categories>
        <category>编程框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>FutrueTask探究</title>
    <url>/2020/04/05/FutrueTask%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>使用FutureTask实现闭锁。提前加载稍后需要的数据。FutureTask继承了<strong>Future和Runnable</strong>接口。</p>
<p>如下段代码，使用FutureTask可以实现闭锁，即可以提前加载需要的数据，在<strong>get</strong>时阻塞，直到运算完成。</p>
<p>最好的实现是实现<strong>Thread</strong>，创建线程完成。当然直接调用<strong>run</strong>方法可以运行，但没有创建线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class futureTaskDemo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    《JAVA并发编程实战》第五章：</span><br><span class="line">    使用FutureTask实现闭锁。提前加载稍后需要的数据。</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    private final FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            return printDataTest();</span><br><span class="line">            &#x2F;&#x2F;return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    private final Thread thread &#x3D; new Thread(futureTask);</span><br><span class="line"></span><br><span class="line">    public void start ()&#123;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int printDataTest()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;futuretesk开始了&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;futuretesk结束了&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * 测试FutureTask,run方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void futureTaskTest()</span><br><span class="line">    &#123;</span><br><span class="line">        futureTask.run();</span><br><span class="line">        try &#123;</span><br><span class="line">            futureTask.get();</span><br><span class="line">            System.out.println(&quot;结束&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * 测试FutureTask,Thread</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void futureTaskTestWithThread()</span><br><span class="line">    &#123;</span><br><span class="line">        start();</span><br><span class="line">        try &#123;</span><br><span class="line">            futureTask.get();</span><br><span class="line">            System.out.println(&quot;结束&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言基础</category>
        <category>JAVA并发</category>
      </categories>
      <tags>
        <tag>JAVA并发编程实战</tag>
        <tag>FutureTask</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA并发容器类探究</title>
    <url>/2020/04/05/JAVA%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h2><p><strong>Vector Hashtable Collections.synchronizedXxx</strong><br>实现线程安全的方式：将状态封装起来，并对每个公有方法进行同步，每次只有一个线程可以访问容器的状态</p>
<p>同步容器类自身线程安全，但可能需要客户端额外加锁。<br>在迭代的时候会遇到问题。容器类的迭代使用Iterator，如果迭代期间没有加锁，并发修改容器，会抛出<strong>ConcurrentModificationException</strong>。<br>同步容器类表现行为是<strong>fail-fast</strong>。</p>
<p>同时要注意隐藏迭代器。toString、hashCode、equals方法等会间接进行迭代操作。</p>
<h2 id="并发容器类"><a href="#并发容器类" class="headerlink" title="并发容器类"></a>并发容器类</h2><p>同步容器类将所有对容器状态的访问都串行化，实现线程安全。眼中降低并发性，造成吞吐量降低。<br>并发容器针对多线程并发访问设计。Java5.0增加<strong>ConcurrentHashMap、CopyOnWriteArrayList、Queue、BlockingQueue</strong>。<br>Java6.0引入<strong>ConcurrentSkipListMap、ConcurrentSkipListSet</strong>。<br>迭代器具有弱一致性（Weakly Consistent）。并非<strong>fail-fast</strong>。可以容忍并发的修改。<br>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性。<br>例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁（Lock Striping），在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。</p>
<p>没有实现加锁实现独占访问。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>Map中的put方法：<br>如果map中包含类该键的映射，则替换旧值，并返回旧值。<br>如果map中不包含该键的映射，则写入。返回null。同时返回null也可表示之前该键对应的值为null。</p>
<p>ConcurrentHashMap中的<strong>putIfAbsent</strong>方法：<br>如果指定的键尚未与值相关联，请将其与给定值相关联。 这相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!map.containsKey(key)) return map.put(key, value); else return map.get(key);</span><br></pre></td></tr></table></figure>
<p>返回值：与指定键相关联的上一个值，如果没有键的映射，返回null。</p>
<h2 id="opyOnWriteArrayList"><a href="#opyOnWriteArrayList" class="headerlink" title="opyOnWriteArrayList"></a>opyOnWriteArrayList</h2><p>CopyOnWriteArrayList：只要正确发布一个事实不可变的对象，访问该对象就不需要进一步同步。CopyOnWriteArrayList利用底层数组的copy实现该安全机制。<br>每次修改时，都会创建并重新发布新的容器副本，见add源码。<br>迭代时调用COWIterator，传入底层数组的引用。在迭代器内部类复制原始数组，所以迭代器用到的数组不会修改，所以可以实现多线程同时对容器进行迭代。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        Object[] es &#x3D; getArray();</span><br><span class="line">        int len &#x3D; es.length;</span><br><span class="line">        es &#x3D; Arrays.copyOf(es, len + 1);</span><br><span class="line">        es[len] &#x3D; e;</span><br><span class="line">        setArray(es);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;** Snapshot of the array *&#x2F;</span><br><span class="line">    private final Object[] snapshot;</span><br><span class="line">    &#x2F;**</span><br><span class="line">        * Index of element to be returned by subsequent call to next.</span><br><span class="line">        *&#x2F;</span><br><span class="line">    private int cursor;</span><br><span class="line"></span><br><span class="line">    COWIterator(Object[] es, int initialCursor) &#123;</span><br><span class="line">        cursor &#x3D; initialCursor;</span><br><span class="line">        snapshot &#x3D; es;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasPrevious() &#123;</span><br><span class="line">        return cursor &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>设计用于在处理之前保留元素的集合。 除了基本的Collection操作之外，队列还提供额外的插入，提取和检查操作。 这些方法中的每一种都有两种形式：如果操作失败，则抛出一个异常，另一种返回一个特殊值（ null或false ，具体取决于操作）。<br>队列通常但不一定是以FIFO（先进先出）方式排序元素。<br>PriorityQueue优先级队列的元素根据它们的有序natural ordering ，或由一个Comparator在队列构造的时候提供，这取决于所使用的构造方法。 优先队列不允许null元素。 依靠自然排序的优先级队列也不允许插入不可比较的对象.<br>如果可能， offer方法插入一个元素，否则返回false 。<br>remove()和poll()方法删除并返回队列的头。 从队列中删除哪个元素是队列排序策略的一个功能，它与实现不同。 remove()和poll()方法在队列为空时的行为不同： remove()方法抛出异常，而poll()方法返回null 。<br>element()和peek()方法返回，但不要删除，头的队列。peek()方法中，如果此队列为空，则返回 null 。<br>Queue实现通常不允许插入null元素。</p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>支持在检索元素时等待队列变为非空的操作，并且在存储元素时等待队列中的空间变得可用。<br>不接受null元素。<br>容量有限。<br>被设计为主要用于<strong>生产者 - 消费者队列</strong>。<br>线程安全。<br>put():将指定的元素插入到此队列中，等待空格可用。<br>take():检索并删除此队列的头，如有必要，等待元素可用。</p>
<p>抛出时，表示该方法是个阻塞方法。<br>当在代码中调用了一个将抛出InterruptedException异常的方法时，该方法就成为了阻塞方法。必须处理中断的响应。两种基本方法：<br>1）传递InterruptedException。避开异常，可以不捕获该异常，抛出。或者捕获该异常后，执行简单清理工作后再次抛出异常。<br>2）恢复中断。对于不能抛出InterruptedException异常的方法，比如时Runnable的实现类时。必须捕获异常，并调用当前线程的interrupt方法恢复中断状态。这样调用栈中更高层的代码将看到引发中断。</p>
<p>不能捕获InterruptedException中断但是不做任何处理。这样高层代码无法对中断采取措施。</p>
<h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><p>BlockingQueue、闭锁（Latch）、FutureTask、信号量（Semaphore）、栅栏（Barrier）</p>
<h3 id="闭锁（Latch）"><a href="#闭锁（Latch）" class="headerlink" title="闭锁（Latch）"></a>闭锁（Latch）</h3><p>实现类：CountDownLatch。<br>允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。<br>给定的计数初始化。 await方法阻塞，直到由于countDown()方法的调用而导致当前计数达到零，之后所有等待线程被释放，并且任何后续的await 调用立即返回。 这是一个一次性的现象 - 计数无法重置。<br>是一种通用的同步工具，可用于多种用途。<br>示例用法1：这是一组类，其中一组工作线程使用两个倒计时锁存器：</p>
<ul>
<li>第一个是启动信号，防止任何工作人员进入，直到驾驶员准备好继续前进;</li>
<li>第二个是完成信号，允许司机等到所有的工作人员完成。<br>示例用法2：将问题划分为N个部分，用一个Runnable来描述每个部分，该Runnable执行该部分并在锁存器上倒计时，并将所有Runnables排队到执行器。 当所有子部分完成时，协调线程将能够通过等待。</li>
</ul>
<h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h3><p>在概念上，信号量维持一组许可证。 如果有必要，每个acquire()都会阻塞，直到许可证可用，然后才能使用它。 每个release()添加许可证，潜在地释放阻塞获取方。 但是，没有使用实际的许可证对象; Semaphore只保留可用数量的计数，并相应地执行。<br>信号量通常用于限制线程数，而不是访问某些（物理或逻辑）资源。<br>此类的构造函数可选择接受公平参数。 当设置为false时，此类不会保证线程获取许可的顺序。当公平设置为真时，信号量保证调用acquire方法的线程被选择以按照它们调用这些方法的顺序获得许可（先进先出; FIFO）。<br>信号量被初始化为一个，并且被使用，使得它只有至多一个允许可用，可以用作互斥锁。 这通常被称为二进制信号量 ，因为它只有两个状态：一个许可证可用，或零个许可证可用。</p>
<h3 id="栅栏（Barrier）"><a href="#栅栏（Barrier）" class="headerlink" title="栅栏（Barrier）"></a>栅栏（Barrier）</h3><p>实现类：CyclicBarrier。<br>允许一组线程全部等待彼此达到共同屏障点的同步辅助。 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为循环 ，因为它可以在等待的线程被释放之后重新使用。<br>CyclicBarrier支持一个可选的Runnable命令，每个屏障点运行一次，调用await()。最后一个线程到达之后，Runnable中的方法执行。</p>
]]></content>
      <categories>
        <category>语言基础</category>
        <category>JAVA并发</category>
      </categories>
      <tags>
        <tag>JAVA并发编程实战</tag>
        <tag>并发容器类</tag>
        <tag>同步工具类</tag>
        <tag>ConcurrentHashMap</tag>
        <tag>CopyOnWriteArrayList</tag>
        <tag>BlockingQueue</tag>
        <tag>CountDownLatch</tag>
        <tag>Semaphore</tag>
        <tag>CyclicBarrier</tag>
      </tags>
  </entry>
  <entry>
    <title>四种线程创建方式</title>
    <url>/2020/04/05/%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="java中创建线程的四种方式"><a href="#java中创建线程的四种方式" class="headerlink" title="java中创建线程的四种方式"></a>java中创建线程的四种方式</h2><p>通常可以通过继承Thread和实现Runnable两种方式创建线程。启动线程需要用start方法。</p>
<blockquote>
<p>1、继承Thread类创建线程<br>2、实现Runnable接口创建线程<br>3、使用Callable和Future创建线程<br>4、使用线程池例如用Executor框架</p>
</blockquote>
<h2 id="创建方式实例"><a href="#创建方式实例" class="headerlink" title="创建方式实例"></a>创建方式实例</h2><h3 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h3><p>定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。<br>创建Thread子类的实例，也就是创建了线程对象.<br>启动线程，即调用线程的start()方法.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 创建方式1：继承Thread类</span><br><span class="line">    *&#x2F;</span><br><span class="line">public class myThread1 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;thread1创建成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">    * 调用方式1</span><br><span class="line">    *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void threadCreate1()</span><br><span class="line">&#123;</span><br><span class="line">    myThread1 thread1 &#x3D; new myThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;new myThread1().start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口创建线程"><a href="#实现Runnable接口创建线程" class="headerlink" title="实现Runnable接口创建线程"></a>实现Runnable接口创建线程</h3><p>定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体<br>创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象<br>第三部依然是通过调用线程对象的start()方法来启动线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 创建方式2：实现Runnable接口</span><br><span class="line">    *&#x2F;</span><br><span class="line">public class myThread2 implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;thread2创建成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">    * 调用方式2</span><br><span class="line">    *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void threadCreate2()</span><br><span class="line">&#123;</span><br><span class="line">    new Thread(new myThread2()).start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;此方式只是创建runnable对象，调用run方法，并没有创建线程</span><br><span class="line">    &#x2F;&#x2F;new myThread2().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Callable和Future创建线程"><a href="#使用Callable和Future创建线程" class="headerlink" title="使用Callable和Future创建线程"></a>使用Callable和Future创建线程</h3><p>创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）<br>使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值<br>使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）<br>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 创建方式3：FutureTask</span><br><span class="line">    *&#x2F;</span><br><span class="line">public class myThread3 implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;thread2创建成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">    * 调用方式3</span><br><span class="line">    *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void threadCreate3()</span><br><span class="line">&#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;thread3创建成功！&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;thread3结束了&quot;);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Thread thread3 &#x3D; new Thread(futureTask);</span><br><span class="line"></span><br><span class="line">    thread3.start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        futureTask.get();</span><br><span class="line">        System.out.println(&quot;结束&quot;);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用线程池例如用Executor框架"><a href="#使用线程池例如用Executor框架" class="headerlink" title="使用线程池例如用Executor框架"></a>使用线程池例如用Executor框架</h3><p>该部分在Executor框架中展开阐述。</p>
<h2 id="Runnable创建线程的优势"><a href="#Runnable创建线程的优势" class="headerlink" title="Runnable创建线程的优势"></a>Runnable创建线程的优势</h2><p>建议使用Runnable来实现多线程。<br>1、<strong>Runnable适合于多个相同程序代码线程去处理统一资源的情况</strong>，把虚拟的cpu（线程）同程序的代码，数据有效分离，较好体现面向对象的编程的思想</p>
<p>2、<strong>Runnable可以避免由于java的单继承机制带来的局限</strong>。可以再继承其他类的同时，还能实现多线程的功能。</p>
<p>3、Runnable能增加程序的健壮性。<strong>代码能够被多个线程共享</strong>。</p>
<p>继承Thread方式创建线程，线程之间不能做资源共享。Runnable接口方式创建线程，通过下列方式启动线程，每启动一次都会创建一个test相关的线程，所以可以实现资源共享。几个线程共享Runnable接口实现类中的资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadDemo</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String []args)</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadTest test&#x3D;new ThreadTest();</span><br><span class="line">        new Thread(test).start();</span><br><span class="line">        new Thread(test).start();</span><br><span class="line">        new Thread(test).start();</span><br><span class="line">        new Thread(test).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadTest implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    private int count&#x3D;10;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        while(count&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;   &quot;+count--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="run和start"><a href="#run和start" class="headerlink" title="run和start"></a>run和start</h2><p>关于调用run方法和start方法：</p>
<p>1、start()方法:启动一个线程，调用该Runnable对象的run()方法，<strong>不能多次启动一个线程</strong>。</p>
<p>2、run()方法:在本线程内调用该Runnable对象的run()方法，可以<strong>重复多次调用</strong>。</p>
<p>3、用start()方法来启动线程，真正实现了<strong>多线程运行</strong>，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。只有调用start方法才是交给jvm管理，才是多线程。</p>
<p>4、run()方法只是类的一个<strong>普通方法</strong>而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，要等待run方法体执行完毕后才可继续执行下面的代码。</p>
]]></content>
      <categories>
        <category>语言基础</category>
        <category>JAVA并发</category>
      </categories>
      <tags>
        <tag>Executor框架</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Executor框架探究</title>
    <url>/2020/04/05/Executor%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>Executor框架的最大优点是把任务的<strong>提交和执行解耦</strong>。要执行任务的人只需把Task描述清楚，然后提交即可。这个Task是怎么被执行的，被谁执行的，什么时候执行的，提交的人就不用关心了。具体点讲，提交一个Callable对象给ExecutorService（如最常用的线程池ThreadPoolExecutor），将得到一个Future对象，调用Future对象的get方法等待执行结果就好了。Executor框架的内部使用了线程池机制，它在java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。<br>Executor框架包括：<strong>线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable</strong>等。<br>Executor接口中之定义了一个方法<strong>execute</strong>（Runnable command），该方法接收一个Runnable实例，它用来执行一个任务，任务即一个实现了Runnable接口的类。<br><strong>ExecutorService</strong>接口继承自Executor接口，它提供了更丰富的实现多线程的方法，比如，ExecutorService提供了关闭自己的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。<br>可以通过多种方法创建Future来描述任务。ExecutorService中所有的<strong>submit</strong>方法都返回Future，从而将一个Runnable或者callable提交给Executor并得到一个Future来获取任务的执行结果或者取消任务。<br>还可以显示的为指定的Runnable或者callable实例化一个FutureTask。从java6开始ExecutorService可以改写newTaskFor方法，创建一个新的FutureTask。</p>
<h2 id="Executor生命周期"><a href="#Executor生命周期" class="headerlink" title="Executor生命周期"></a>Executor生命周期</h2><p>可以调用ExecutorService的<strong>shutdown（）</strong>方法来平滑地关闭 ExecutorService，调用该方法后，将导致ExecutorService停止接受任何新的任务且等待已经提交的任务执行完成(已经提交的任务会分两类：一类是已经在执行的，另一类是还没有开始执行的)，当所有已经提交的任务执行完毕后将会关闭ExecutorService。因此我们一般用该接口来实现和管理多线程。<br>ExecutorService的生命周期包括三种状态：<strong>运行、关闭、终止</strong>。创建后便进入运行状态，当调用了shutdown（）方法时，便进入关闭状态，此时意味着ExecutorService不再接受新的任务，但它还在执行已经提交了的任务，当素有已经提交了的任务执行完后，便到达终止状态。如果不调用shutdown（）方法，ExecutorService会一直处在运行状态，不断接收新的任务，执行新的任务，服务器端一般不需要关闭它，保持一直运行即可。</p>
<h3 id="ExecutorService的invokeAll方法"><a href="#ExecutorService的invokeAll方法" class="headerlink" title="ExecutorService的invokeAll方法"></a>ExecutorService的invokeAll方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                            long timeout,</span><br><span class="line">                            TimeUnit unit)</span><br><span class="line">                    throws InterruptedException</span><br></pre></td></tr></table></figure>
<p>多个任务提交并返回一组Future结果。</p>
<h3 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h3><p>一种将新异步任务的生产与已完成任务的结果消耗相分离的服务。 生产者submit执行任务。 消费者take完成任务并按照完成的顺序处理其结果。<br>CompletionService将<strong>Executor和BlockingQueue</strong>结合在一起。<br><strong>ExecutorCompletionService</strong>是CompletionService实现类。计算完成后，调用FutureTask的<strong>done</strong>方法。当提交任务时，包装任务为一个<strong>QueueingFuture</strong>（FutureTask的子类），改写子类的done方法。将结果放入<strong>BlockingQueue</strong>中。<br>take或poll方法委托给lockingQueue，阻塞式获得队列中完成的任务的Future结果。</p>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>Executors提供了一系列<strong>工厂方法</strong>用于创先线程池，返回的线程池都实现了ExecutorService接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads)</span><br></pre></td></tr></table></figure>
<p>创建固定数目线程的线程池。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool()</span><br></pre></td></tr></table></figure>
<p>创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线   程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor()</span><br></pre></td></tr></table></figure>
<p>创建一个单线程化的Executor。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</span><br></pre></td></tr></table></figure>
<p>创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。</p>
<p>一般来说，<strong>CachedTheadPool</strong>在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选，只有当这种方式会引发问题时（比如需要大量长时间面向连接的线程时），才需要考虑用FixedThreadPool。</p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>newFixedThreadPool、newCachedThreadPool、newSingleThreadExecutor均返回<strong>ThreadPoolExecutor</strong>对象。该类继承自<strong>AbstractExecutorService</strong>，AbstractExecutorService继承自ThreadPoolExecutor。<br>ThreadPoolExecutor构造函数的参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                            int maximumPoolSize,</span><br><span class="line">                            long keepAliveTime,</span><br><span class="line">                            TimeUnit unit,</span><br><span class="line">                            BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                            ThreadFactory threadFactory,</span><br><span class="line">                            RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<p>任何<strong>BlockingQueue</strong>可用于传送和保留提交的任务。 这个队列的使用与池大小相互作用：<br>如果少于corePoolSize线程正在运行，Executor总是喜欢添加一个新线程，而不是排队。<br>如果corePoolSize或更多的线程正在运行，Executor总是喜欢排队请求而不是添加一个新的线程。<br>如果请求无法排队，则会创建一个新线程，除非这将超出maximumPoolSize，否则任务将被拒绝。</p>
<h4 id="排队策略"><a href="#排队策略" class="headerlink" title="排队策略"></a>排队策略</h4><p>排队有三种一般策略：<br><strong>直接切换</strong> 一个工作队列的一个很好的默认选择是一个SynchronousQueue ，将任务交给线程，无需另外控制。 在这里，如果没有线程可以立即运行，那么尝试排队任务会失败，因此将构建一个新的线程。 处理可能具有内部依赖关系的请求集时，此策略可避免锁定。 直接切换通常需要无限制的maximumPoolSizes，以避免拒绝新提交的任务。 这反过来允许无限线程增长的可能性，当命令继续以平均速度比他们可以处理的速度更快地到达时。<br><strong>无界队列</strong> 使用无界队列（例如LinkedBlockingQueue没有预定容量）会导致新的任务，在队列中等待，当所有corePoolSize线程都很忙。 因此，不会再创建corePoolSize线程。 （因此，最大值大小的值没有任何影响。）每个任务完全独立于其他任务时，这可能是适当的，因此任务不会影响其他执行; 例如，在网页服务器中。 虽然这种排队风格可以有助于平滑瞬态突发的请求，但是当命令继续达到的平均速度比可以处理的速度更快时，它承认无界工作队列增长的可能性。<br><strong>有边界的队列</strong> 有限队列（例如， ArrayBlockingQueue ）有助于在使用有限maxPoolSizes时防止资源耗尽，但可能更难调整和控制。 队列大小和最大池大小可能彼此交易：使用大队列和小型池可以最大限度地减少CPU使用率，OS资源和上下文切换开销，但可能导致人为的低吞吐量。 如果任务频繁阻塞（例如，如果它们是I / O绑定），则系统可能能够安排比您允许的更多线程的时间。 使用小型队列通常需要较大的池大小，这样可以使CPU繁忙，但可能会遇到不可接受的调度开销，这也降低了吞吐量。</p>
<h4 id="典型的实现"><a href="#典型的实现" class="headerlink" title="典型的实现"></a>典型的实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                    60L, TimeUnit.SECONDS,</span><br><span class="line">                                    new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>语言基础</category>
        <category>JAVA并发</category>
      </categories>
      <tags>
        <tag>Executor框架</tag>
        <tag>JAVA并发编程实战</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码探究</title>
    <url>/2020/04/05/HashMap%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h2><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。允许null的值和null键。</p>
<h2 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h2><p>HashMap 基于 Hash 算法实现的。<br>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标。<br>存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中。<br>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。<br>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p>
<h2 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h2><p>数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。<br>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>
<h2 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h2><p>如果两个对象相等，则hashcode一定也是相同的。<br>两个对象相等,对两个equals方法返回true。<br>两个对象有相同的hashcode值，它们也不一定是相等的。<br>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖。<br>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p>
<h2 id="与equals的区别"><a href="#与equals的区别" class="headerlink" title="==与equals的区别"></a>==与equals的区别</h2><p>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同。<br>==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同。</p>
<h2 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h2><p>当我们put的时候，首先计算 key的hash值，这里调用了 hash方法，hash方法实际是让key.hashCode()与key.hashCode()&gt;&gt;&gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是2的幂，计算下标index = (table.length - 1) &amp; hash，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p>
<p>put方法调用putVal方法,进行hash运算，作为参数传递给putVal。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部hash运算，减少碰撞。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">            boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    &#x2F;&#x2F; 步骤①：tab为空则创建 </span><br><span class="line">    &#x2F;&#x2F; table未初始化或者长度为0，进行扩容</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    &#x2F;&#x2F; 步骤②：计算index，并对null做处理  </span><br><span class="line">    &#x2F;&#x2F; (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">    &#x2F;&#x2F; 桶中已经存在元素</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        &#x2F;&#x2F; 步骤③：节点key存在，直接覆盖value </span><br><span class="line">        &#x2F;&#x2F; 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            &#x2F;&#x2F; 将第一个元素赋值给e，用e来记录</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        &#x2F;&#x2F; 步骤④：判断该链为红黑树 </span><br><span class="line">        &#x2F;&#x2F; hash值不相等，即key不相等；为红黑树结点</span><br><span class="line">        &#x2F;&#x2F; 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为nul</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        &#x2F;&#x2F; 步骤⑤：该链为链表 </span><br><span class="line">        &#x2F;&#x2F; 为链表结点</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 在链表最末插入结点</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F; 到达链表的尾部</span><br><span class="line">                &#x2F;&#x2F;判断该链表尾部指针是不是空的</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 在尾部插入新结点</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    &#x2F;&#x2F;判断链表的长度是否达到转化红黑树的临界值，临界值为8表节点大于8且数组长度大于等于64</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        &#x2F;&#x2F;链表结构转树形结构</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    &#x2F;&#x2F; 跳出循环</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 判断链表中结点的key值与插入的元素的key值是否相等</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    &#x2F;&#x2F; 相等，跳出循环</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; 用于遍历桶中的链表，与前面的e &#x3D; p.next组合，可以遍历链表</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span><br><span class="line">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">            &#x2F;&#x2F; 记录e的value</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            &#x2F;&#x2F; onlyIfAbsent为false或者旧值为null</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                &#x2F;&#x2F;用新值替换旧值</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            &#x2F;&#x2F; 访问后回调</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            &#x2F;&#x2F; 返回旧值</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    &#x2F;&#x2F; 步骤⑥：超过最大容量就扩容 </span><br><span class="line">    &#x2F;&#x2F; 实际大小大于阈值则扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    &#x2F;&#x2F; 插入后回调</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node类的定义。可以看出，Node中存放运算后的hash值，键值对，及next节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash &#x3D; hash;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue &#x3D; value;</span><br><span class="line">        value &#x3D; newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; this)</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表节点大于8且数组长度大于等于64时，链表转化为红黑树。当链表节点大于8且数组长度小于64时，优先扩容。下面为treeifyBin源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">        do &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);</span><br><span class="line">            if (tl &#x3D;&#x3D; null)</span><br><span class="line">                hd &#x3D; p;</span><br><span class="line">            else &#123;</span><br><span class="line">                p.prev &#x3D; tl;</span><br><span class="line">                tl.next &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl &#x3D; p;</span><br><span class="line">        &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        if ((tab[index] &#x3D; hd) !&#x3D; null)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h2><p>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p>
<p>每次扩展的时候，都是扩展2倍；</p>
<p>扩展后Node对象的位置要么在原位置，要么移动到原位置偏移原容量值的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;&#x2F;&#x2F;oldTab指向hash桶数组</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;&#x2F;&#x2F;如果oldCap不为空的话，就是hash桶数组不为空</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;&#x2F;&#x2F;如果大于最大容量了，就赋值为整数最大的阀值</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;&#x2F;&#x2F;返回</span><br><span class="line">        &#125;&#x2F;&#x2F;如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold 双倍扩容阀值threshold</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span><br><span class="line">    &#x2F;&#x2F; 直接将该值赋给新的容量</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    &#x2F;&#x2F; 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span><br><span class="line">    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 新的threshold &#x3D; 新的cap * 0.75</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line">    &#x2F;&#x2F; 计算出新的数组长度后赋给当前成员变量table</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];&#x2F;&#x2F;新建hash桶数组</span><br><span class="line">    table &#x3D; newTab;&#x2F;&#x2F;将新数组的值复制给旧的hash桶数组</span><br><span class="line">    &#x2F;&#x2F; 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 遍历新数组的所有桶下标</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F; 如果e.next&#x3D;&#x3D;null，代表桶中就一个元素，不存在链表或者红黑树</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    &#x2F;&#x2F; 用同样的hash映射算法把该元素加入新的数组</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                &#x2F;&#x2F; 如果e是TreeNode并且e.next!&#x3D;null，那么处理树中元素的重排</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                &#x2F;&#x2F; e是链表的头并且e.next!&#x3D;null，那么处理链表中元素重排</span><br><span class="line">                else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    &#x2F;&#x2F; loHead,loTail 代表扩容后不用变换下标，见注1</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F; hiHead,hiTail 代表扩容后变换下标，见注1</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    &#x2F;&#x2F; 遍历链表</span><br><span class="line">                    do &#123;             </span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                &#x2F;&#x2F; 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span><br><span class="line">                                &#x2F;&#x2F; 代表下标保持不变的链表的头元素</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                            else                                </span><br><span class="line">                                &#x2F;&#x2F; loTail.next指向当前e</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            &#x2F;&#x2F; loTail指向当前的元素e</span><br><span class="line">                            &#x2F;&#x2F; 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span><br><span class="line">                            &#x2F;&#x2F; 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span><br><span class="line">                            &#x2F;&#x2F; 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span><br><span class="line">                            loTail &#x3D; e;                           </span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                &#x2F;&#x2F; 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    &#x2F;&#x2F; 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap实现"><a href="#ConcurrentHashMap实现" class="headerlink" title="ConcurrentHashMap实现"></a>ConcurrentHashMap实现</h2><p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现。</p>
<p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
]]></content>
      <categories>
        <category>语言基础</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>容器类</tag>
        <tag>非线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal深入探究</title>
    <url>/2020/03/29/ThreadLocal%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h2><p>ThreadLocal是线程Thread中属性<strong>threadLocals</strong>的管理者。<br>ThreadLocal类用来提供<strong>线程内部的局部变量</strong>。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是<strong>private static</strong>类型的，用于关联线程和线程的上下文。</p>
<h2 id="与Thread、ThreadLocalMap的联系"><a href="#与Thread、ThreadLocalMap的联系" class="headerlink" title="与Thread、ThreadLocalMap的联系"></a>与Thread、ThreadLocalMap的联系</h2><p>ThreadLocal类内部定义<strong>ThreadLocalMap</strong>类。ThreadLocalMap内部存储着Entry(ThreadLocal<?> k, Object v) 数组，键类型为ThreadLocal<?> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        &#x2F;** The value associated with this ThreadLocal. *&#x2F;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            super(k);</span><br><span class="line">            value &#x3D; v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread中定义如下的threadLocals。threadLocals作为Thread中的属性，是一个特殊的ThreadLocalMap 。每一个线程管理自己的threadLocals，key值是<strong>ThreadLocal</strong>实例，而value值这是我们设置的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal内部方法实现"><a href="#ThreadLocal内部方法实现" class="headerlink" title="ThreadLocal内部方法实现"></a>ThreadLocal内部方法实现</h2><p>initialValue。该函数在调用get函数的时候会第一次调用，但是如果一开始就调用了set函数，则该函数不会被调用。通常该函数只会被调用一次，除非手动调用了remove函数之后又调用get函数，这种情况下，get函数中还是会调用initialValue函数。该函数是protected类型的，很显然是建议在子类重载该函数的，所以通常该函数都会以匿名内部类的形式被重载，以指定初始值，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected T initialValue() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get。该函数用来获取与当前线程关联的ThreadLocal的值，如果当前线程没有该ThreadLocal的值，则调用initialValue函数获取初始值返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;查找map中以当前threadlocal为键的键值对，如果没有返回null</span><br><span class="line">        ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result &#x3D; (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;没有map或者没有找到对应的键的键值对，则创建map或设置初始值</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getMap。返回丹当前线程的threadLocals。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setInitialValue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    &#x2F;&#x2F;initialValue返回值作为初始值</span><br><span class="line">    T value &#x3D; initialValue();</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    &#x2F;&#x2F;map存在则插入键值对</span><br><span class="line">    if (map !&#x3D; null) &#123;</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F;map不存在创建map，并初始化键值对（this，value）</span><br><span class="line">    else &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this instanceof TerminatingThreadLocal) &#123;</span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) this);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createMap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    &#x2F;&#x2F;map不存在创建map，并初始化键值对（this，value）</span><br><span class="line">    t.threadLocals &#x3D; new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null) &#123;</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remove</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">        ThreadLocalMap m &#x3D; getMap(Thread.currentThread());</span><br><span class="line">        if (m !&#x3D; null) &#123;</span><br><span class="line">            m.remove(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>ThreadLocalMap是使用ThreadLocal的<strong>弱引用</strong>作为Key。</p>
]]></content>
      <categories>
        <category>语言基础</category>
        <category>JAVA并发</category>
      </categories>
      <tags>
        <tag>JAVA并发编程实战</tag>
        <tag>并发</tag>
        <tag>JAVA源码</tag>
        <tag>多线程</tag>
        <tag>线程隔离</tag>
      </tags>
  </entry>
  <entry>
    <title>那些基于next搭建hexo我踩过的坑</title>
    <url>/2020/03/29/%E9%82%A3%E4%BA%9B%E5%9F%BA%E4%BA%8Enext%E6%90%AD%E5%BB%BAhexo%E6%88%91%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h2 id="为什么选择next"><a href="#为什么选择next" class="headerlink" title="为什么选择next"></a>为什么选择next</h2><p>近期一直想搭建自己的博客，记录下自己的学习历程。之前一直使用CSDN写一点东西，还是会感到受限制，当然也想更加极客范一点，所以就有了搭自己博客的想法。选择hexo一方面是hexo是出色的静态博客框架，对于我们这些对前端技术不是很了解的同学们较为友好，可以基于现有主题改造成自己喜欢的样式。另一方面也是用户较多，遇到问题相关的解决方案也很多。可以让我们专注于博客的内容上。<br>为什么选择next呢？刚开始搭建的时候，我尝试过两款视觉效果较为绚丽的主题，一个是matery，一个是butterfly。这两款主题在我的多次尝试下，在我的系统下一直配置出错，搜索解决方案调试也无果，最终放弃。选择next一方面是next主题简约大气的主题风格，再有就是next较为强大的配置选项。下面介绍我的搭建历程，希望能为大家提供借鉴。</p>
<h2 id="hexo静态博客搭建流程"><a href="#hexo静态博客搭建流程" class="headerlink" title="hexo静态博客搭建流程"></a>hexo静态博客搭建流程</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>hexo框架需要依赖Node.js环境，所以需要安装Node.js。此安装会同时安装npm。安装完成后可以输入如下指令查看是否安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>为加快npm下载速度，可以设置永久npm镜像源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看npm的配置</span></span><br><span class="line">npm config list</span><br><span class="line"><span class="comment"># 默认源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br><span class="line"><span class="comment"># 临时改变镜像源</span></span><br><span class="line">npm --registry=https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 永久设置为淘宝镜像源</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 另一种方式，编辑 ~/.npmrc 加入下面内容</span></span><br><span class="line">registry = https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h4 id="下载Git"><a href="#下载Git" class="headerlink" title="下载Git"></a>下载Git</h4><blockquote>
<p>Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 Git 是 [Linus Torvalds](<a href="https://baike.baidu.com/item/&gt;Linus" target="_blank" rel="noopener">https://baike.baidu.com/item/&gt;Linus</a> Torvalds/9336769) 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
</blockquote>
<p>git的安装和配置就不在此赘述了。</p>
<h4 id="hexo安装与配置"><a href="#hexo安装与配置" class="headerlink" title="hexo安装与配置"></a>hexo安装与配置</h4><h5 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h5><p>输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo</span><br></pre></td></tr></table></figure>
<h5 id="创建hexo文件夹"><a href="#创建hexo文件夹" class="headerlink" title="创建hexo文件夹"></a>创建hexo文件夹</h5><p>创建hexo文件夹，并cd进入文件夹中。</p>
<h5 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h5><p>cd进入文件夹后，初始化hexo。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>hexo初始化完成。可以在hexo -g,hexo -s后在本地运行。</p>
<p>hexo初始化完成后，下面我们的任务就是配置拓展hexo的功能模块，并优化hexo主题。</p>
<p>hexo配置到github就不在此赘述了。</p>
<h2 id="next主题安装配置"><a href="#next主题安装配置" class="headerlink" title="next主题安装配置"></a>next主题安装配置</h2><p>下面介绍next主题安装及配置。本文安装的next版本为6.0版本。在Next6版本上其实增加了很多Next5需要手动配置的东西，并且Next5已经停止维护了，如果不太喜欢自己手动去配置的话，建议使用Next6版本。</p>
<h3 id="next安装"><a href="#next安装" class="headerlink" title="next安装"></a>next安装</h3><p>进入博客根目录下，进入themes目录，执行下列克隆操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git</span><br></pre></td></tr></table></figure>
<p>在themes目录下会生成hexo-theme-next文件夹。</p>
<h3 id="hexo配置next主题"><a href="#hexo配置next主题" class="headerlink" title="hexo配置next主题"></a>hexo配置next主题</h3><p>在管理员权限下博客根目录下打开_config.yml文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure>
<p>找到theme，修改为hexo-theme-next。便完成了主题配置。</p>
<h3 id="next主题修改及配置"><a href="#next主题修改及配置" class="headerlink" title="next主题修改及配置"></a>next主题修改及配置</h3><p>下面介绍一下如何配置Next主题的配置文件。配置分为两部分，一部分需要配置博客根目录下的_config.yml文件，修改主配置。主题相关的配置需要修改主题文件夹下的_config.yml文件。</p>
<h4 id="主配置文件修改"><a href="#主配置文件修改" class="headerlink" title="主配置文件修改"></a>主配置文件修改</h4><p>下段代码是配置我们hexo博客主要信息的配置代码，需要修改为我们自己的信息。包括titie、description、author等。其中language要修改为中文。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 金年轻</span><br><span class="line">subtitle: &#39;&#39;</span><br><span class="line">description: &#39;金年轻的个人博客，欢迎交流&#39;</span><br><span class="line">keywords:</span><br><span class="line">author: 金年轻</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#39;&#39;</span><br></pre></td></tr></table></figure>

<h4 id="主题配置文件修改"><a href="#主题配置文件修改" class="headerlink" title="主题配置文件修改"></a>主题配置文件修改</h4><p>首先打开上面下载或者克隆好的Next主题目录，即在hexo/themes下面，然后打开其_config.xml主题配置文件。我们一一修改。</p>
<p>由于配置文件是yml，如果对yml语法不太熟的小伙伴，注意每个配置之间都必须有空格，不然报错。注意:后面有一个空格，所有yml语法都是这样。</p>
<h5 id="菜单栏设置"><a href="#菜单栏设置" class="headerlink" title="菜单栏设置"></a>菜单栏设置</h5><p>搜索menu，找到如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  #tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  #categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br><span class="line"></span><br><span class="line"># Enable&#x2F;Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true  #表示是否显示菜单图标icons</span><br><span class="line">  badges: false  # 显示每个菜单下面有多少个内容</span><br></pre></td></tr></table></figure>
<p>我们一般要开启home、tags、categories、archives这几个基本菜单栏标签。<br>其中后面||后面表示的fontawesome中的图标名称，如果想要修改图标，可以去FontAwesome官网找自己喜欢的图标样式。</p>
<h5 id="Next主题风格设置"><a href="#Next主题风格设置" class="headerlink" title="Next主题风格设置"></a>Next主题风格设置</h5><p>next有四种主题风格。搜索schema，找到如下代码。可以根据喜好切换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>
<h5 id="社交链接设置"><a href="#社交链接设置" class="headerlink" title="社交链接设置"></a>社交链接设置</h5><p>搜索social，找到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#social:</span><br><span class="line">  #GitHub: https:&#x2F;&#x2F;github.com&#x2F;yourname || github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || envelope</span><br><span class="line">  #Google: https:&#x2F;&#x2F;plus.google.com&#x2F;yourname || google</span><br><span class="line">  #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;yourname || twitter</span><br><span class="line">  #FB Page: https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname || facebook</span><br><span class="line">  #VK Group: https:&#x2F;&#x2F;vk.com&#x2F;yourname || vk</span><br><span class="line">  #StackOverflow: https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname || stack-overflow</span><br><span class="line">  #YouTube: https:&#x2F;&#x2F;youtube.com&#x2F;yourname || youtube</span><br><span class="line">  #Instagram: https:&#x2F;&#x2F;instagram.com&#x2F;yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure>
<h5 id="友情链接设置"><a href="#友情链接设置" class="headerlink" title="友情链接设置"></a>友情链接设置</h5><p>搜索links，找到如下配置。添加友情链接即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: Links</span><br><span class="line">links_layout: block</span><br><span class="line">#links_layout: inline</span><br><span class="line">#links:</span><br><span class="line">  #Title: http:&#x2F;&#x2F;example.com&#x2F;</span><br></pre></td></tr></table></figure>
<h5 id="文章字数统计设置"><a href="#文章字数统计设置" class="headerlink" title="文章字数统计设置"></a>文章字数统计设置</h5><p>搜索post_wordcount，找到如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>
<p>注意开启上述设置必须要添加hexo-symbols-count-time模块依赖，即在hexo站点根目录下使用npm install hexo-symbols-count-time –save命令安装模块。</p>
<h5 id="侧边栏头像设置"><a href="#侧边栏头像设置" class="headerlink" title="侧边栏头像设置"></a>侧边栏头像设置</h5><p>搜索avatar，找到如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif</span><br><span class="line">  # in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif</span><br><span class="line">  # You can also use other linking images.</span><br><span class="line">  url:  # 此处是头像的地址</span><br><span class="line">  # If true, the avatar would be dispalyed in circle. </span><br><span class="line">  rounded: true   # 设置头像是否为圆形</span><br><span class="line">  # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span><br><span class="line">  opacity: 1    # 设置不透明度，1为完全不透明，0为完全透明</span><br><span class="line">  # If true, the avatar would be rotated with the cursor.</span><br><span class="line">  rotated: true   # 设置鼠标放到头像上是否旋转</span><br></pre></td></tr></table></figure>
<p>其中我们需要配置url，此处是我们头像的地址。rounded可以设置头像是否为圆形，rotated可以设置鼠标放到头像上是否旋转。</p>
<h5 id="代码块风格设置"><a href="#代码块风格设置" class="headerlink" title="代码块风格设置"></a>代码块风格设置</h5><p>搜索highlight_theme，有以下多种风格：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Code Highlight theme</span><br><span class="line"># Available values: normal | night | night eighties | night blue | night bright</span><br><span class="line"># https:&#x2F;&#x2F;github.com&#x2F;chriskempson&#x2F;tomorrow-theme</span><br><span class="line">highlight_theme: night eighties</span><br></pre></td></tr></table></figure>
<h5 id="添加valine评论系统"><a href="#添加valine评论系统" class="headerlink" title="添加valine评论系统"></a>添加valine评论系统</h5><p>搜索valine，找到如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Valine.</span><br><span class="line"># You can get your appid and appkey from https:&#x2F;&#x2F;leancloud.cn</span><br><span class="line"># more info please open https:&#x2F;&#x2F;valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid:   # your leancloud application appid</span><br><span class="line">  appkey:  # your leancloud application appkey</span><br><span class="line">  notify: false # mail notifier , https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 留下邮箱，有回复时你将收到提醒，邮箱不会被公开。 # comment box placeholder</span><br><span class="line">  avatar: wavatar # gravatar style https:&#x2F;&#x2F;valine.js.org&#x2F;avatar&#x2F;</span><br><span class="line">  guest_info: nick,mail # custom comment header default: nick,mail,link</span><br><span class="line">  pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure>
<p>注意由于valine是第三方插件，因此要先去<a href="https://leancloud.cn" target="_blank" rel="noopener">https://leancloud.cn</a> 网站注册，获取到appid和appkey后放到这里就ok了。其中avatar是设置默认头像，可以去<a href="https://valine.js.org/avatar" target="_blank" rel="noopener">https://valine.js.org/avatar</a> 选择默认头像，然后在这里设置名字即可。<br>配置中遇到头像与用户名不显示的问题。经过排查发现，用户名需要手动输入才会显示。抓包发现评论发送时request请求头中字段中nick字段为用户名，在leancloud账户中创建的class中的comment中存储我们的评论数据。调试发现必须建立comment及counter类才能正常使用我们的评论系统，以为valine是依托leancloud实现的。在评论时输入邮箱，头像显示。</p>
<h5 id="开启不蒜子统计功能"><a href="#开启不蒜子统计功能" class="headerlink" title="开启不蒜子统计功能"></a>开启不蒜子统计功能</h5><p>搜索busuanzi_count，可以配置如下，也可以使用默认设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Show Views&#x2F;Visitors of the website&#x2F;page with busuanzi.</span><br><span class="line"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi&#x2F;</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  site_uv: true #total visitors</span><br><span class="line">  site_uv_icon:  #user-circle</span><br><span class="line">  site_uv_header: 你是来访的第</span><br><span class="line">  site_uv_footer: 位小伙伴</span><br><span class="line">  site_pv: false #total views</span><br><span class="line">  site_pv_icon: eye</span><br><span class="line">  site_pv_header: 访问次数：</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  post_views: false</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>
<h5 id="开启本地博客搜索功能"><a href="#开启本地博客搜索功能" class="headerlink" title="开启本地博客搜索功能"></a>开启本地博客搜索功能</h5><p>搜索local_search，设置代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # unescape html strings to the readable one</span><br><span class="line">  unescape: false</span><br></pre></td></tr></table></figure>
<p>注意该搜索功能需要依赖hexo-generator-searchdb插件，依然还是使用命令npm install hexo-generator-searchdb –save来进行安装。然后 在hexo站点根目录的末尾，加入以下代码即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<h5 id="开启背景动画"><a href="#开启背景动画" class="headerlink" title="开启背景动画"></a>开启背景动画</h5><h2 id="Valine评论系统配置"><a href="#Valine评论系统配置" class="headerlink" title="Valine评论系统配置"></a>Valine评论系统配置</h2><p>NexT v6.0+中，背景动画Canvas_nest无效。找到three标签，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># JavaScript 3D library.</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-three</span><br><span class="line">three:</span><br><span class="line">  enable: true</span><br><span class="line">  three_waves: true</span><br><span class="line">  canvas_lines: false</span><br><span class="line">  canvas_sphere: false</span><br></pre></td></tr></table></figure>
<p>配置完成后运行发现并没有背景动画。我们发现该配置有依赖项，我们在next目录下的source/lib文件夹下clone该项目：<a href="https://github.com/theme-next/theme-next-three" target="_blank" rel="noopener">https://github.com/theme-next/theme-next-three</a> 。再次运行可以加载背景动画。</p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>至此在一波熬夜后，基本完成了基于next的博客搭建，并部署在了github上。目前只实现了基本的功能需求，鉴于访问速度还是很慢，所以后续我会继续优化，会尽快把博客部署到服务器上。<br>下面放上我的博客地址：<a href="https://buaajz.github.io">https://buaajz.github.io</a>。欢迎大家进来交流，共同学习。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p>markdown语法：<a href="https://www.jianshu.com/p/191d1e21f7ed/" target="_blank" rel="noopener">https://www.jianshu.com/p/191d1e21f7ed/</a><br><a href="https://www.jianshu.com/p/2e318226c88d" target="_blank" rel="noopener">https://www.jianshu.com/p/2e318226c88d</a></p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
